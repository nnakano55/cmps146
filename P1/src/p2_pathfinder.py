from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):
    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to
    Returns:
        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}	# The dictionary that will be returned with the costs    distances = {}		# The dictonary that will store the boxes    backboxes = {}    destination_boxes = []	    for i in mesh["boxes"]:        if i[0]<source_point[0] and source_point[0]<i[1]:             if i[2]<source_point[1] and source_point[1]<i[3]:                 # The priority queue                 queue = [(0, source_point, i)]                 distances[i] = 0                 backboxes[i] = None           if i[0]<destination_point[0] and destination_point[0]<i[1]:             if i[2]<destination_point[1] and destination_point[1]<i[3]:                 destination_boxes = i				       # The dictionary that will store the backpointers    backpointers = {}    backpointers[source_point] = None    while queue:        current_dist, current_node, current_boxes = heappop(queue)        # Check if current node is the destination_point        if current_boxes == destination_boxes:            # List containing all cells from source_point to destination_point            path = [current_node]            boxes[current_boxes] = 0            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list            path.append(destination_point)            current_back_node = backpointers[current_node]            while current_back_node is not None:                path.append(current_back_node)                current_back_node = backpointers[current_back_node]			            current_back_boxes = backboxes[current_boxes]            while current_back_boxes is not None:                boxes[current_back_boxes] = 0                current_back_boxes = backboxes[current_back_boxes]				            	            print(path)            return path, boxes.keys()        # Calculate cost from current note to all the adjacent ones        for adj_node_boxes in mesh["adj"][current_boxes]:            x1 = adj_node_boxes[0]            x2 = adj_node_boxes[1]            y1 = adj_node_boxes[2]            y2 = adj_node_boxes[3]            if x1 < current_boxes[0]:                x1 = current_boxes[0]            elif x2 > current_boxes[1]:                x2 = current_boxes[1]            elif y1 > current_boxes[2]:                y1 = current_boxes[2]            elif y2 < current_boxes[3]:                y2 = current_boxes[3]						            adj_node_x = max(x1,min(x2,current_node[0]))            adj_node_y = max(y2,min(y1,current_node[1]))            adj_node = (adj_node_x,adj_node_y)			            pathcost = (pow((adj_node[0]-current_node[0]),2)+pow((adj_node[1]-current_node[1]),2))**0.5+current_dist            # If the cost is new            if adj_node_boxes not in distances or pathcost < distances[adj_node_boxes]:                distances[adj_node_boxes] = pathcost                backpointers[adj_node] = current_node                backboxes[adj_node_boxes] = current_boxes                heappush(queue, (pathcost, adj_node, adj_node_boxes))				   				