from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}            indicateD = 0    indicateS = 0	# The dictionary that will be returned with the costs    distances = {}    distances_BACK = {}		# The dictonary that will store the boxes    backboxes = {}    backboxes_BACK = {}	    queue=[]    queue_BACK = []	    # The dictionary that will store the backpointers    backpointers = {}    backpointers_BACK = {}		    for i in mesh["boxes"]:        if i[0]<=source_point[0] and source_point[0]<=i[1]:             if i[2]<=source_point[1] and source_point[1]<=i[3]:                 # The priority queue                 queue = [(0, source_point, i)]                 distances[i] = 0                 backboxes[i] = None                 backpointers[i] = (source_point, source_point)                 indicateS = 1                 				         if i[0]<destination_point[0] and destination_point[0]<i[1]:             if i[2]<destination_point[1] and destination_point[1]<i[3]:                 queue_BACK = [(0, destination_point, i)]                 distances_BACK[i] = 0                 backboxes_BACK[i] = None                 backpointers_BACK[i] = (destination_point, destination_point)                 indicateD = 1		    #print(source_point, destination_point)     if indicateD == 0 or indicateS == 0:        print("EXCEPTION! Source or Destination ERROR!")        return path,boxes.keys()    while queue:        current_dist, current_node, current_boxes = heappop(queue)        if queue_BACK:            current_dist_BACK, current_node_BACK, current_boxes_BACK = heappop(queue_BACK)        #print(backboxes, "  ", backboxes_BACK)        # Check if current node is the destination_point        for ke in backboxes_BACK:            if ke == current_boxes:            # List containing all cells from source_point to destination_point                tupMeet = (backpointers[current_boxes][1], backpointers_BACK[current_boxes][1])                #print(tupMeet)                path.append(tupMeet)                boxes[current_boxes] = 0            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list                current_back_boxes = current_boxes                while current_back_boxes is not None:                    boxes[current_back_boxes] = 0                    path.append(backpointers[current_back_boxes])                    #print(path, "Forward")                    current_back_boxes = backboxes[current_back_boxes]			                current_back_boxes_Back = current_boxes                while current_back_boxes_Back is not None:                    boxes[current_back_boxes_Back] = 0                    path.append(backpointers_BACK[current_back_boxes_Back])                    #print(path,"Back")                    current_back_boxes_Back = backboxes_BACK[current_back_boxes_Back]	                #print(path) 	                return path, boxes.keys()        # Calculate cost from current note to all the adjacent ones        #print("Here")        for adj_node_boxes in mesh["adj"][current_boxes]:				            x1 = adj_node_boxes[0]            x2 = adj_node_boxes[1]            y1 = adj_node_boxes[2]            y2 = adj_node_boxes[3]			            if y1 == current_boxes[3]:                if(x1 < current_boxes[0]):                    x1 = current_boxes[0]                if(x2 > current_boxes[1]):                    x2 = current_boxes[1]                adj_node_x = max(x1,min(x2,current_node[0]))                adj_node = (adj_node_x, y1)					            if y2 == current_boxes[2]:                if(x1 < current_boxes[0]):                    x1 = current_boxes[0]                if(x2 > current_boxes[1]):                    x2 = current_boxes[1]					                adj_node_x = max(x1,min(x2,current_node[0]))                adj_node = (adj_node_x, y2)					            if x1 == current_boxes[1]:                if (y1 < current_boxes[2]):                    y1 = current_boxes[2]                if (y2 > current_boxes[3]):                    y2 = current_boxes[3]					                adj_node_y = max(y2,min(y1,current_node[1]))                adj_node = (x1,adj_node_y)					            if x2 == current_boxes[0]:                if (y1 < current_boxes[2]):                    y1 = current_boxes[2]                if (y2 > current_boxes[3]):                    y2 = current_boxes[3]                adj_node_y = max(y2,min(y1,current_node[1]))                adj_node = (x2,adj_node_y)									            estCost = (pow((current_node[0]-destination_point[0]),2)+pow((current_node[1]-destination_point[1]),2))**0.5            pathcost = (pow((adj_node[0]-current_node[0]),2)+pow((adj_node[1]-current_node[1]),2))**0.5+current_dist+estCost            # If the cost is new            if adj_node_boxes not in distances or pathcost < distances[adj_node_boxes]:                distances[adj_node_boxes] = pathcost                tup = (current_node, adj_node)                backpointers[adj_node_boxes] = tup                backboxes[adj_node_boxes] = current_boxes                heappush(queue, (pathcost, adj_node, adj_node_boxes))					        for adj_node_boxes_BACK in mesh["adj"][current_boxes_BACK]:            x1_BACK = adj_node_boxes_BACK[0]            x2_BACK = adj_node_boxes_BACK[1]            y1_BACK = adj_node_boxes_BACK[2]            y2_BACK = adj_node_boxes_BACK[3]                        if y1_BACK == current_boxes_BACK[3]:                if(x1_BACK < current_boxes_BACK[0]):                    x1_BACK = current_boxes_BACK[0]                if(x2_BACK > current_boxes_BACK[1]):                    x2_BACK = current_boxes_BACK[1]                adj_node_x_BACK = max(x1_BACK,min(x2_BACK,current_node_BACK[0]))                adj_node_BACK = (adj_node_x_BACK, y1_BACK)					            if y2_BACK == current_boxes_BACK[2]:                if(x1_BACK < current_boxes_BACK[0]):                    x1_BACK = current_boxes_BACK[0]                if(x2_BACK > current_boxes_BACK[1]):                    x2_BACK = current_boxes_BACK[1]					                adj_node_x_BACK = max(x1_BACK,min(x2_BACK,current_node_BACK[0]))                adj_node_BACK = (adj_node_x_BACK, y2_BACK)					            if x1_BACK == current_boxes_BACK[1]:                if (y1_BACK < current_boxes_BACK[2]):                    y1_BACK = current_boxes_BACK[2]                if (y2_BACK > current_boxes_BACK[3]):                    y2_BACK = current_boxes_BACK[3]					                adj_node_y_BACK = max(y2_BACK,min(y1_BACK,current_node_BACK[1]))                adj_node_BACK = (x1_BACK,adj_node_y_BACK)					            if x2_BACK == current_boxes_BACK[0]:                if (y1_BACK < current_boxes_BACK[2]):                    y1_BACK = current_boxes_BACK[2]                if (y2_BACK > current_boxes_BACK[3]):                    y2_BACK = current_boxes_BACK[3]                adj_node_y_BACK = max(y2_BACK,min(y1_BACK,current_node_BACK[1]))                adj_node_BACK = (x2_BACK,adj_node_y_BACK)									            estCost_BACK = (pow((current_node_BACK[0]-source_point[0]),2)+pow((current_node_BACK[1]-source_point[1]),2))**0.5            pathcost_BACK = (pow((adj_node_BACK[0]-current_node_BACK[0]),2)+pow((adj_node_BACK[1]-current_node_BACK[1]),2))**0.5+current_dist_BACK+estCost_BACK            # If the cost is new            if adj_node_boxes_BACK not in distances_BACK or pathcost_BACK < distances_BACK[adj_node_boxes_BACK]:                distances_BACK[adj_node_boxes_BACK] = pathcost_BACK                tup_Back = (current_node_BACK, adj_node_BACK)                backpointers_BACK[adj_node_boxes_BACK] = tup_Back                backboxes_BACK[adj_node_boxes_BACK] = current_boxes_BACK                heappush(queue_BACK, (pathcost_BACK, adj_node_BACK, adj_node_boxes_BACK))    print("Exception! No Path Exist!")    return path, boxes.keys()								