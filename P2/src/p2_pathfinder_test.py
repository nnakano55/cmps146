from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}            indicateD = 0    indicateS = 0	# The dictionary that will be returned with the costs    distances = {}    distances_BACK = []		# The dictonary that will store the boxes    backboxes = {} 	    queue=[]	    # The dictionary that will store the backpointers    backpointers = {}    backpointers_BACK = {}		    for i in mesh["boxes"]:        if i[0]<=source_point[0] and source_point[0]<=i[1]:             if i[2]<=source_point[1] and source_point[1]<=i[3]:                 # The priority queue                 queue = [(0, source_point, i)]                 distances[i] = 0                 backboxes[i] = None                 backpointers[i] = (source_point, source_point)                 indicateS = 1                 				         if i[0]<destination_point[0] and destination_point[0]<i[1]:             if i[2]<destination_point[1] and destination_point[1]<i[3]:                 distances_BACK = i                 indicateD = 1		    #print(source_point, destination_point)     if indicateD == 0 or indicateS == 0:        print("EXCEPTION! Source or Destination ERROR!")        return path,boxes.keys()    while queue:        current_dist, current_node, current_boxes = heappop(queue)        # Check if current node is the destination_point        if current_boxes == distances_BACK:            # List containing all cells from source_point to destination_point            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_boxes = current_boxes            while current_back_boxes is not None:                boxes[current_back_boxes] = 0                path.append(backpointers[current_back_boxes])                    #print(path, "Forward")                 current_back_boxes = backboxes[current_back_boxes]               	                #print(path) 	            return path, boxes.keys()        # Calculate cost from current note to all the adjacent ones        #print("Here")        for adj_node_boxes in mesh["adj"][current_boxes]:				            x1 = adj_node_boxes[2]            x2 = adj_node_boxes[3]            y1 = adj_node_boxes[0]            y2 = adj_node_boxes[1]			            if y1 == current_boxes[1]:                if(x1 < current_boxes[2]):                    x1 = current_boxes[2]                if(x2 > current_boxes[3]):                    x2 = current_boxes[3]                           					            if y2 == current_boxes[0]:                if(x1 < current_boxes[2]):                    x1 = current_boxes[2]                if(x2 > current_boxes[3]):                    x2 = current_boxes[3]					            					            if x1 == current_boxes[3]:                if (y1 < current_boxes[0]):                    y1 = current_boxes[0]                if (y2 > current_boxes[1]):                    y2 = current_boxes[1]								            if x2 == current_boxes[2]:                if (y1 < current_boxes[0]):                    y1 = current_boxes[0]                if (y2 > current_boxes[1]):                    y2 = current_boxes[1]                            adj_node_y = max(y1,min(y2,current_node[0]))            adj_node_x = max(x1,min(x2,current_node[1]))            adj_node = (adj_node_y, adj_node_x)									            estCost = abs(adj_node[0]-destination_point[0])+abs(adj_node[1]-destination_point[1])            pathcost = (pow((adj_node[0]-current_node[0]),2)+pow((adj_node[1]-current_node[1]),2))**0.5+distances[current_boxes]            # If the cost is new            if adj_node_boxes not in distances.keys() or pathcost + estCost < distances[adj_node_boxes]:                distances[adj_node_boxes] = pathcost                tup = (current_node, adj_node)                backpointers[adj_node_boxes] = tup                backboxes[adj_node_boxes] = current_boxes                heappush(queue, (pathcost+estCost, adj_node, adj_node_boxes))    print("Exception! No Path Exist!")    return path, boxes.keys()								