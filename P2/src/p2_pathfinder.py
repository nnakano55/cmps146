"""P2 Navmensh Pathfinding p2_pathfinder.pyProgrammers:	Xuya Gao	Noriaki Nakano """from heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    # the path and boxes to be returned     path = []    boxes = {}		# check is source and destination point is valid             indicateD = 0    indicateS = 0		# The dictionary that will be returned with the costs    distances = {}    distances_BACK = {}		# The dictonary that will store the boxes    backboxes = {}    backboxes_BACK = {}    # the queue for the bidirectional A* search     queue=[]    queue_BACK = []	    # The dictionary that will store the backpointers    backpointers = {}    backpointers_BACK = {}		    for i in mesh["boxes"]:        if i[0]<=source_point[0] and source_point[0]<=i[1]:             if i[2]<=source_point[1] and source_point[1]<=i[3]:                 # The priority queue                 heappush(queue,(0, destination_point, i))                 distances[i] = 0                 backboxes[i] = None                 backpointers[i] = (source_point)                 indicateS = 1                 				         if i[0]<=destination_point[0] and destination_point[0]<=i[1]:             if i[2]<=destination_point[1] and destination_point[1]<=i[3]:                 heappush(queue,(0, source_point, i))                 distances_BACK[i] = 0                 backboxes_BACK[i] = None                 backpointers_BACK[i] = (destination_point)                 indicateD = 1     if indicateD == 0 or indicateS == 0:        print("EXCEPTION! Source or Destination ERROR!")        return path,boxes.keys()    while queue:        current_dist_P, goal, current_boxes = heappop(queue)        # Check if current node is the destination_point        if current_boxes in backboxes_BACK.keys() and goal == destination_point:            tupMeet_S = (backpointers[current_boxes], backpointers_BACK[current_boxes])            path.append(tupMeet_S)            boxes[current_boxes] = 0            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_boxes = current_boxes            while backboxes[current_back_boxes] is not None:                boxes[backboxes[current_back_boxes]] = 0                tup1 = ((backpointers[current_back_boxes], backpointers[backboxes[current_back_boxes]]))                path.append(tup1)                current_back_boxes = backboxes[current_back_boxes]				            current_back_boxes_Back = current_boxes            while backboxes_BACK[current_back_boxes_Back] is not None:                 boxes[backboxes_BACK[current_back_boxes_Back]] = 0                 tup2 = ((backpointers_BACK[current_back_boxes_Back], backpointers_BACK[backboxes_BACK[current_back_boxes_Back]] ))                 path.append(tup2)                 current_back_boxes_Back = backboxes_BACK[current_back_boxes_Back]	            return path, boxes.keys()				        if current_boxes in backboxes.keys()and goal == source_point:            tupMeet_D = (backpointers[current_boxes], backpointers_BACK[current_boxes])            path.append(tupMeet_D)            boxes[current_boxes] = 0            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list            current_back_boxes = current_boxes            while backboxes[current_back_boxes] is not None:                boxes[backboxes[current_back_boxes]] = 0                tup1 = ((backpointers[current_back_boxes], backpointers[backboxes[current_back_boxes]]))                path.append(tup1)                current_back_boxes = backboxes[current_back_boxes]								            current_back_boxes_Back = current_boxes            while backboxes_BACK[current_back_boxes_Back] is not None:                boxes[backboxes_BACK[current_back_boxes_Back]] = 0                tup2 = ((backpointers_BACK[current_back_boxes_Back], backpointers_BACK[backboxes_BACK[current_back_boxes_Back]] ))                path.append(tup2)                current_back_boxes_Back = backboxes_BACK[current_back_boxes_Back]                    return path, boxes.keys()                # Calculate cost from current note to all the adjacent ones        if goal == destination_point:            for adj_node_boxes in mesh["adj"][current_boxes]:				                x1 = adj_node_boxes[2]                x2 = adj_node_boxes[3]                y1 = adj_node_boxes[0]                y2 = adj_node_boxes[1]			                if y1 == current_boxes[1]:                    if(x1 < current_boxes[2]):                        x1 = current_boxes[2]                    if(x2 > current_boxes[3]):                        x2 = current_boxes[3]                    adj_node_x = max(x1,min(x2,backpointers[current_boxes][1]))                    adj_node = (y1, adj_node_x)					                elif y2 == current_boxes[0]:                    if(x1 < current_boxes[2]):                         x1 = current_boxes[2]                    if(x2 > current_boxes[3]):                        x2 = current_boxes[3]					                    adj_node_x = max(x1,min(x2,backpointers[current_boxes][1]))                    adj_node = (y2, adj_node_x)					                elif x1 == current_boxes[3]:                    if (y1 < current_boxes[0]):                        y1 = current_boxes[0]                    if (y2 > current_boxes[1]):                        y2 = current_boxes[1]					                    adj_node_y = max(y1,min(y2,backpointers[current_boxes][0]))                    adj_node = (adj_node_y, x1)					                elif x2 == current_boxes[2]:                    if (y1 < current_boxes[0]):                        y1 = current_boxes[0]                    if (y2 > current_boxes[1]):                        y2 = current_boxes[1]                    adj_node_y = max(y1,min(y2,backpointers[current_boxes][0]))                    adj_node = (adj_node_y, x2)									                estCost = abs(adj_node[0]-destination_point[0])+abs(adj_node[1]-destination_point[1])                pathcost = (pow((adj_node[0]-backpointers[current_boxes][0]),2)+pow((adj_node[1]-backpointers[current_boxes][1]),2))**0.5+distances[current_boxes]            # If the cost is new                if adj_node_boxes not in distances.keys() or pathcost < distances[adj_node_boxes]:                    distances[adj_node_boxes] = pathcost                    backpointers[adj_node_boxes] = adj_node                    backboxes[adj_node_boxes] = current_boxes                    heappush(queue, (estCost+pathcost, goal, adj_node_boxes))					        if goal == source_point:            for adj_node_boxes_BACK in mesh["adj"][current_boxes]:                x1_BACK = adj_node_boxes_BACK[2]                x2_BACK = adj_node_boxes_BACK[3]                y1_BACK = adj_node_boxes_BACK[0]                y2_BACK = adj_node_boxes_BACK[1]                            if y1_BACK == current_boxes[1]:                    if(x1_BACK < current_boxes[2]):                        x1_BACK = current_boxes[2]                    if(x2_BACK > current_boxes[3]):                        x2_BACK = current_boxes[3]                    adj_node_x_BACK = max(x1_BACK,min(x2_BACK,backpointers_BACK[current_boxes][1]))                    adj_node_BACK = (y1_BACK, adj_node_x_BACK)					                elif y2_BACK == current_boxes[0]:                    if(x1_BACK < current_boxes[2]):                        x1_BACK = current_boxes[2]                    if(x2_BACK > current_boxes[3]):                        x2_BACK = current_boxes[3]					                    adj_node_x_BACK = max(x1_BACK,min(x2_BACK,backpointers_BACK[current_boxes][1]))                    adj_node_BACK = (y2_BACK, adj_node_x_BACK)					                elif x1_BACK == current_boxes[3]:                    if (y1_BACK < current_boxes[0]):                        y1_BACK = current_boxes[0]                    if (y2_BACK > current_boxes[1]):                        y2_BACK = current_boxes[1]					                    adj_node_y_BACK = max(y1_BACK,min(y2_BACK,backpointers_BACK[current_boxes][0]))                    adj_node_BACK = (adj_node_y_BACK, x1_BACK)					                elif x2_BACK == current_boxes[2]:                    if (y1_BACK < current_boxes[0]):                        y1_BACK = current_boxes[0]                    if (y2_BACK > current_boxes[1]):                        y2_BACK = current_boxes[1]                    adj_node_y_BACK = max(y1_BACK,min(y2_BACK,backpointers_BACK[current_boxes][0]))                    adj_node_BACK = (adj_node_y_BACK, x2_BACK)									                estCost_BACK = abs(adj_node_BACK[0]-source_point[0])+abs(adj_node_BACK[1]-source_point[1])                pathcost_BACK = (pow((adj_node_BACK[0]-backpointers_BACK[current_boxes][0]),2)+pow((adj_node_BACK[1]-backpointers_BACK[current_boxes][1]),2))**0.5+distances_BACK[current_boxes]            # If the cost is new                if adj_node_boxes_BACK not in distances_BACK.keys() or pathcost_BACK < distances_BACK[adj_node_boxes_BACK]:                    distances_BACK[adj_node_boxes_BACK] = pathcost_BACK                    backpointers_BACK[adj_node_boxes_BACK] = adj_node_BACK                    backboxes_BACK[adj_node_boxes_BACK] = current_boxes                    heappush(queue, (estCost_BACK+pathcost_BACK, goal, adj_node_boxes_BACK))    print("Exception! No Path Exist!")    return path, boxes.keys()								