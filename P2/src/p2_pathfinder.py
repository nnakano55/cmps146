from heapq import heappop, heappushimport segment_pathdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}            indicateD = 0    indicateS = 0	# The dictionary that will be returned with the costs    distances = {}    distances_BACK = {}		# The dictonary that will store the boxes    backboxes = {}    backboxes_BACK = {}	    queue=[]    queue_BACK = []	    # The dictionary that will store the backpointers    backpointers = {}    backpointers_BACK = {}	    for i in mesh["boxes"]:        if i[0]<=source_point[0] and source_point[0]<=i[1]:             if i[2]<=source_point[1] and source_point[1]<=i[3]:                 # The priority queue                 queue = [(0, source_point, i)]                 distances[i] = 0                 backboxes[i] = None                 backpointers[i] = (source_point, source_point)                 indicateS = 1                 				         if i[0]<destination_point[0] and destination_point[0]<i[1]:             if i[2]<destination_point[1] and destination_point[1]<i[3]:                 queue_BACK = [(0, destination_point, i)]                 distances_BACK[i] = 0                 backboxes_BACK[i] = None                 backpointers_BACK[i] = (destination_point, destination_point)                 indicateD = 1		    print(source_point, destination_point)     if indicateD == 0 or indicateS == 0:        print("EXCEPTION! Source or Destination ERROR!")        return None    while queue:        current_dist, current_node, current_boxes = heappop(queue)        current_dist_BACK, current_node_BACK, current_boxes_BACK = heappop(queue_BACK)        #print(backboxes, "  ", backboxes_BACK)        # Check if current node is the destination_point        for ke in backboxes_BACK:            if ke == current_boxes:            # List containing all cells from source_point to destination_point                tupMeet = (backpointers[current_boxes][1], backpointers_BACK[current_boxes][0])                print(tupMeet)                #path.append(tupMeet)                path.append(((current_boxes[0] + current_boxes[1])/2, (current_boxes[2] + current_boxes[3])/2))                boxes[current_boxes] = 0            # Go backwards from destination_point until the source using backpointers            # and add all the nodes in the shortest path into a list                current_back_boxes = backboxes[current_boxes]                while current_back_boxes is not None:                    boxes[current_back_boxes] = 0                    #path.append(backpointers[current_back_boxes])                    print("feelsbadman")                    print(current_back_boxes)                    x1,x2,y1,y2 = [v for v in current_back_boxes]                    path.append(((x1+x2)/2, (y1+y2)/2))                    #print(path, "Forward")                    current_back_boxes = backboxes[current_back_boxes]			                current_back_boxes_Back = backboxes_BACK[current_boxes]                while current_back_boxes_Back is not None:                    boxes[current_back_boxes_Back] = 0                    #path.append(backpointers_BACK[current_back_boxes_Back])                    x1,x2,y1,y2 = [v for v in current_back_boxes_Back]                    path.insert(0,((x1+x2)/2, (y1+y2)/2))                    #print(path,"Back")                    current_back_boxes_Back = backboxes_BACK[current_back_boxes_Back]                    print(segment_path)				                print("check segment_path_rect")                print(path)                print(segment_path.segment_path(path))                return segment_path.segment_path(path), boxes.keys()        # Calculate cost from current note to all the adjacent ones        #print("Here")        for adj_node_boxes in mesh["adj"][current_boxes]:            x1 = adj_node_boxes[0]            x2 = adj_node_boxes[1]            y1 = adj_node_boxes[2]            y2 = adj_node_boxes[3]            if x1 < current_boxes[0]:                x1 = current_boxes[0]            elif x2 > current_boxes[1]:                x2 = current_boxes[1]            elif y1 > current_boxes[2]:                y1 = current_boxes[2]            elif y2 < current_boxes[3]:                y2 = current_boxes[3]						            adj_node_x = max(x1,min(x2,current_node[0]))            adj_node_y = max(y2,min(y1,current_node[1]))            adj_node = (adj_node_x,adj_node_y)			            estCost = (pow((current_node[0]-destination_point[0]),2)+pow((current_node[1]-destination_point[1]),2))**0.5            pathcost = (pow((adj_node[0]-current_node[0]),2)+pow((adj_node[1]-current_node[1]),2))**0.5+current_dist+estCost            # If the cost is new            if adj_node_boxes not in distances or pathcost < distances[adj_node_boxes]:                distances[adj_node_boxes] = pathcost                tup = (current_node, adj_node)                backpointers[adj_node_boxes] = tup                backboxes[adj_node_boxes] = current_boxes                heappush(queue, (pathcost, adj_node, adj_node_boxes))					        for adj_node_boxes_BACK in mesh["adj"][current_boxes_BACK]:            x1_BACK = adj_node_boxes_BACK[0]            x2_BACK = adj_node_boxes_BACK[1]            y1_BACK = adj_node_boxes_BACK[2]            y2_BACK = adj_node_boxes_BACK[3]            if x1_BACK < current_boxes_BACK[0]:                x1_BACK = current_boxes_BACK[0]            elif x2_BACK > current_boxes_BACK[1]:                x2_BACK = current_boxes_BACK[1]            elif y1_BACK > current_boxes_BACK[2]:                y1_BACK = current_boxes_BACK[2]            elif y2_BACK < current_boxes_BACK[3]:                y2_BACK = current_boxes_BACK[3]						            adj_node_x_BACK = max(x1_BACK,min(x2_BACK,current_node_BACK[0]))            adj_node_y_BACK = max(y2_BACK,min(y1_BACK,current_node_BACK[1]))            adj_node_BACK = (adj_node_x_BACK,adj_node_y_BACK)			            estCost_BACK = (pow((current_node_BACK[0]-source_point[0]),2)+pow((current_node_BACK[1]-source_point[1]),2))**0.5            pathcost_BACK = (pow((adj_node_BACK[0]-current_node_BACK[0]),2)+pow((adj_node_BACK[1]-current_node_BACK[1]),2))**0.5+current_dist_BACK+estCost_BACK            # If the cost is new            if adj_node_boxes_BACK not in distances_BACK or pathcost_BACK < distances_BACK[adj_node_boxes_BACK]:                distances_BACK[adj_node_boxes_BACK] = pathcost_BACK                tup_Back = (current_node_BACK, adj_node_BACK)                backpointers_BACK[adj_node_boxes_BACK] = tup_Back                backboxes_BACK[adj_node_boxes_BACK] = current_boxes_BACK                heappush(queue_BACK, (pathcost_BACK, adj_node_BACK, adj_node_boxes_BACK))    print("Exception! No Path Exist!")    return None								